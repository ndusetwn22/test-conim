{"ast":null,"code":"// Helper functions for filtering\nexport var defaultMatcher=function defaultMatcher(filterText,node){return node.name.toLowerCase().indexOf(filterText.toLowerCase())!==-1;};export var findNode=function findNode(node,filter,matcher){return matcher(filter,node)||// i match\nnode.children&&// or i have decendents and one of them match\nnode.children.length&&!!node.children.find(function(child){return findNode(child,filter,matcher);});};export var filterTree=function filterTree(node,filter){var matcher=arguments.length>2&&arguments[2]!==undefined?arguments[2]:defaultMatcher;// If im an exact match then all my children get to stay\nif(matcher(filter,node)||!node.children){return node;}// If not then only keep the ones that match or have matching descendants\nvar filtered=node.children.filter(function(child){return findNode(child,filter,matcher);}).map(function(child){return filterTree(child,filter,matcher);});return Object.assign({},node,{children:filtered});};export var expandFilteredNodes=function expandFilteredNodes(node,filter){var matcher=arguments.length>2&&arguments[2]!==undefined?arguments[2]:defaultMatcher;var children=node.children;if(!children||children.length===0){return Object.assign({},node,{toggled:false});}var childrenWithMatches=node.children.filter(function(child){return findNode(child,filter,matcher);});var shouldExpand=childrenWithMatches.length>0;// If im going to expand, go through all the matches and see if thier children need to expand\nif(shouldExpand){children=childrenWithMatches.map(function(child){return expandFilteredNodes(child,filter,matcher);});}return Object.assign({},node,{children:children,toggled:shouldExpand});};","map":{"version":3,"sources":["/Users/pandusetiawan/Documents/react/df-v1.2/src/extensions/treeview/Filter.js"],"names":["defaultMatcher","filterText","node","name","toLowerCase","indexOf","findNode","filter","matcher","children","length","find","child","filterTree","filtered","map","Object","assign","expandFilteredNodes","toggled","childrenWithMatches","shouldExpand"],"mappings":"AAAA;AACA,MAAO,IAAMA,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAACC,UAAD,CAAaC,IAAb,CAAsB,CAClD,MAAOA,CAAAA,IAAI,CAACC,IAAL,CAAUC,WAAV,GAAwBC,OAAxB,CAAgCJ,UAAU,CAACG,WAAX,EAAhC,IAA8D,CAAC,CAAtE,CACD,CAFM,CAIP,MAAO,IAAME,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAACJ,IAAD,CAAOK,MAAP,CAAeC,OAAf,CAA2B,CACjD,MACEA,CAAAA,OAAO,CAACD,MAAD,CAASL,IAAT,CAAP,EAAyB;AACxBA,IAAI,CAACO,QAAL,EAAiB;AAChBP,IAAI,CAACO,QAAL,CAAcC,MADf,EAEC,CAAC,CAACR,IAAI,CAACO,QAAL,CAAcE,IAAd,CAAmB,SAAAC,KAAK,QAAIN,CAAAA,QAAQ,CAACM,KAAD,CAAQL,MAAR,CAAgBC,OAAhB,CAAZ,EAAxB,CAJN,CAMD,CAPM,CASP,MAAO,IAAMK,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACX,IAAD,CAAOK,MAAP,CAA4C,IAA7BC,CAAAA,OAA6B,2DAAnBR,cAAmB,CACpE;AACA,GAAIQ,OAAO,CAACD,MAAD,CAASL,IAAT,CAAP,EAAyB,CAACA,IAAI,CAACO,QAAnC,CAA6C,CAC3C,MAAOP,CAAAA,IAAP,CACD,CACD;AACA,GAAMY,CAAAA,QAAQ,CAAGZ,IAAI,CAACO,QAAL,CACdF,MADc,CACP,SAAAK,KAAK,QAAIN,CAAAA,QAAQ,CAACM,KAAD,CAAQL,MAAR,CAAgBC,OAAhB,CAAZ,EADE,EAEdO,GAFc,CAEV,SAAAH,KAAK,QAAIC,CAAAA,UAAU,CAACD,KAAD,CAAQL,MAAR,CAAgBC,OAAhB,CAAd,EAFK,CAAjB,CAGA,MAAOQ,CAAAA,MAAM,CAACC,MAAP,CAAc,EAAd,CAAkBf,IAAlB,CAAwB,CAAEO,QAAQ,CAAEK,QAAZ,CAAxB,CAAP,CACD,CAVM,CAYP,MAAO,IAAMI,CAAAA,mBAAmB,CAAG,QAAtBA,CAAAA,mBAAsB,CAAChB,IAAD,CAAOK,MAAP,CAA4C,IAA7BC,CAAAA,OAA6B,2DAAnBR,cAAmB,CAC7E,GAAIS,CAAAA,QAAQ,CAAGP,IAAI,CAACO,QAApB,CACA,GAAI,CAACA,QAAD,EAAaA,QAAQ,CAACC,MAAT,GAAoB,CAArC,CAAwC,CACtC,MAAOM,CAAAA,MAAM,CAACC,MAAP,CAAc,EAAd,CAAkBf,IAAlB,CAAwB,CAAEiB,OAAO,CAAE,KAAX,CAAxB,CAAP,CACD,CACD,GAAMC,CAAAA,mBAAmB,CAAGlB,IAAI,CAACO,QAAL,CAAcF,MAAd,CAAqB,SAAAK,KAAK,QACpDN,CAAAA,QAAQ,CAACM,KAAD,CAAQL,MAAR,CAAgBC,OAAhB,CAD4C,EAA1B,CAA5B,CAGA,GAAMa,CAAAA,YAAY,CAAGD,mBAAmB,CAACV,MAApB,CAA6B,CAAlD,CACA;AACA,GAAIW,YAAJ,CAAkB,CAChBZ,QAAQ,CAAGW,mBAAmB,CAACL,GAApB,CAAwB,SAAAH,KAAK,CAAI,CAC1C,MAAOM,CAAAA,mBAAmB,CAACN,KAAD,CAAQL,MAAR,CAAgBC,OAAhB,CAA1B,CACD,CAFU,CAAX,CAGD,CACD,MAAOQ,CAAAA,MAAM,CAACC,MAAP,CAAc,EAAd,CAAkBf,IAAlB,CAAwB,CAC7BO,QAAQ,CAAEA,QADmB,CAE7BU,OAAO,CAAEE,YAFoB,CAAxB,CAAP,CAID,CAnBM","sourcesContent":["// Helper functions for filtering\nexport const defaultMatcher = (filterText, node) => {\n  return node.name.toLowerCase().indexOf(filterText.toLowerCase()) !== -1\n}\n\nexport const findNode = (node, filter, matcher) => {\n  return (\n    matcher(filter, node) || // i match\n    (node.children && // or i have decendents and one of them match\n      node.children.length &&\n      !!node.children.find(child => findNode(child, filter, matcher)))\n  )\n}\n\nexport const filterTree = (node, filter, matcher = defaultMatcher) => {\n  // If im an exact match then all my children get to stay\n  if (matcher(filter, node) || !node.children) {\n    return node\n  }\n  // If not then only keep the ones that match or have matching descendants\n  const filtered = node.children\n    .filter(child => findNode(child, filter, matcher))\n    .map(child => filterTree(child, filter, matcher))\n  return Object.assign({}, node, { children: filtered })\n}\n\nexport const expandFilteredNodes = (node, filter, matcher = defaultMatcher) => {\n  let children = node.children\n  if (!children || children.length === 0) {\n    return Object.assign({}, node, { toggled: false })\n  }\n  const childrenWithMatches = node.children.filter(child =>\n    findNode(child, filter, matcher)\n  )\n  const shouldExpand = childrenWithMatches.length > 0\n  // If im going to expand, go through all the matches and see if thier children need to expand\n  if (shouldExpand) {\n    children = childrenWithMatches.map(child => {\n      return expandFilteredNodes(child, filter, matcher)\n    })\n  }\n  return Object.assign({}, node, {\n    children: children,\n    toggled: shouldExpand\n  })\n}\n"]},"metadata":{},"sourceType":"module"}