{"ast":null,"code":"// Helper functions for filtering\nexport const defaultMatcher = (filterText, node) => {\n  return node.name.toLowerCase().indexOf(filterText.toLowerCase()) !== -1;\n};\nexport const findNode = (node, filter, matcher) => {\n  return matcher(filter, node) || // i match\n  node.children && // or i have decendents and one of them match\n  node.children.length && !!node.children.find(child => findNode(child, filter, matcher));\n};\nexport const filterTree = (node, filter, matcher = defaultMatcher) => {\n  // If im an exact match then all my children get to stay\n  if (matcher(filter, node) || !node.children) {\n    return node;\n  } // If not then only keep the ones that match or have matching descendants\n\n\n  const filtered = node.children.filter(child => findNode(child, filter, matcher)).map(child => filterTree(child, filter, matcher));\n  return Object.assign({}, node, {\n    children: filtered\n  });\n};\nexport const expandFilteredNodes = (node, filter, matcher = defaultMatcher) => {\n  let children = node.children;\n\n  if (!children || children.length === 0) {\n    return Object.assign({}, node, {\n      toggled: false\n    });\n  }\n\n  const childrenWithMatches = node.children.filter(child => findNode(child, filter, matcher));\n  const shouldExpand = childrenWithMatches.length > 0; // If im going to expand, go through all the matches and see if thier children need to expand\n\n  if (shouldExpand) {\n    children = childrenWithMatches.map(child => {\n      return expandFilteredNodes(child, filter, matcher);\n    });\n  }\n\n  return Object.assign({}, node, {\n    children: children,\n    toggled: shouldExpand\n  });\n};","map":{"version":3,"sources":["E:/react/template-belajar-react/src/extensions/treeview/Filter.js"],"names":["defaultMatcher","filterText","node","name","toLowerCase","indexOf","findNode","filter","matcher","children","length","find","child","filterTree","filtered","map","Object","assign","expandFilteredNodes","toggled","childrenWithMatches","shouldExpand"],"mappings":"AAAA;AACA,OAAO,MAAMA,cAAc,GAAG,CAACC,UAAD,EAAaC,IAAb,KAAsB;AAClD,SAAOA,IAAI,CAACC,IAAL,CAAUC,WAAV,GAAwBC,OAAxB,CAAgCJ,UAAU,CAACG,WAAX,EAAhC,MAA8D,CAAC,CAAtE;AACD,CAFM;AAIP,OAAO,MAAME,QAAQ,GAAG,CAACJ,IAAD,EAAOK,MAAP,EAAeC,OAAf,KAA2B;AACjD,SACEA,OAAO,CAACD,MAAD,EAASL,IAAT,CAAP,IAAyB;AACxBA,EAAAA,IAAI,CAACO,QAAL,IAAiB;AAChBP,EAAAA,IAAI,CAACO,QAAL,CAAcC,MADf,IAEC,CAAC,CAACR,IAAI,CAACO,QAAL,CAAcE,IAAd,CAAmBC,KAAK,IAAIN,QAAQ,CAACM,KAAD,EAAQL,MAAR,EAAgBC,OAAhB,CAApC,CAJN;AAMD,CAPM;AASP,OAAO,MAAMK,UAAU,GAAG,CAACX,IAAD,EAAOK,MAAP,EAAeC,OAAO,GAAGR,cAAzB,KAA4C;AACpE;AACA,MAAIQ,OAAO,CAACD,MAAD,EAASL,IAAT,CAAP,IAAyB,CAACA,IAAI,CAACO,QAAnC,EAA6C;AAC3C,WAAOP,IAAP;AACD,GAJmE,CAKpE;;;AACA,QAAMY,QAAQ,GAAGZ,IAAI,CAACO,QAAL,CACdF,MADc,CACPK,KAAK,IAAIN,QAAQ,CAACM,KAAD,EAAQL,MAAR,EAAgBC,OAAhB,CADV,EAEdO,GAFc,CAEVH,KAAK,IAAIC,UAAU,CAACD,KAAD,EAAQL,MAAR,EAAgBC,OAAhB,CAFT,CAAjB;AAGA,SAAOQ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBf,IAAlB,EAAwB;AAAEO,IAAAA,QAAQ,EAAEK;AAAZ,GAAxB,CAAP;AACD,CAVM;AAYP,OAAO,MAAMI,mBAAmB,GAAG,CAAChB,IAAD,EAAOK,MAAP,EAAeC,OAAO,GAAGR,cAAzB,KAA4C;AAC7E,MAAIS,QAAQ,GAAGP,IAAI,CAACO,QAApB;;AACA,MAAI,CAACA,QAAD,IAAaA,QAAQ,CAACC,MAAT,KAAoB,CAArC,EAAwC;AACtC,WAAOM,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBf,IAAlB,EAAwB;AAAEiB,MAAAA,OAAO,EAAE;AAAX,KAAxB,CAAP;AACD;;AACD,QAAMC,mBAAmB,GAAGlB,IAAI,CAACO,QAAL,CAAcF,MAAd,CAAqBK,KAAK,IACpDN,QAAQ,CAACM,KAAD,EAAQL,MAAR,EAAgBC,OAAhB,CADkB,CAA5B;AAGA,QAAMa,YAAY,GAAGD,mBAAmB,CAACV,MAApB,GAA6B,CAAlD,CAR6E,CAS7E;;AACA,MAAIW,YAAJ,EAAkB;AAChBZ,IAAAA,QAAQ,GAAGW,mBAAmB,CAACL,GAApB,CAAwBH,KAAK,IAAI;AAC1C,aAAOM,mBAAmB,CAACN,KAAD,EAAQL,MAAR,EAAgBC,OAAhB,CAA1B;AACD,KAFU,CAAX;AAGD;;AACD,SAAOQ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBf,IAAlB,EAAwB;AAC7BO,IAAAA,QAAQ,EAAEA,QADmB;AAE7BU,IAAAA,OAAO,EAAEE;AAFoB,GAAxB,CAAP;AAID,CAnBM","sourcesContent":["// Helper functions for filtering\nexport const defaultMatcher = (filterText, node) => {\n  return node.name.toLowerCase().indexOf(filterText.toLowerCase()) !== -1\n}\n\nexport const findNode = (node, filter, matcher) => {\n  return (\n    matcher(filter, node) || // i match\n    (node.children && // or i have decendents and one of them match\n      node.children.length &&\n      !!node.children.find(child => findNode(child, filter, matcher)))\n  )\n}\n\nexport const filterTree = (node, filter, matcher = defaultMatcher) => {\n  // If im an exact match then all my children get to stay\n  if (matcher(filter, node) || !node.children) {\n    return node\n  }\n  // If not then only keep the ones that match or have matching descendants\n  const filtered = node.children\n    .filter(child => findNode(child, filter, matcher))\n    .map(child => filterTree(child, filter, matcher))\n  return Object.assign({}, node, { children: filtered })\n}\n\nexport const expandFilteredNodes = (node, filter, matcher = defaultMatcher) => {\n  let children = node.children\n  if (!children || children.length === 0) {\n    return Object.assign({}, node, { toggled: false })\n  }\n  const childrenWithMatches = node.children.filter(child =>\n    findNode(child, filter, matcher)\n  )\n  const shouldExpand = childrenWithMatches.length > 0\n  // If im going to expand, go through all the matches and see if thier children need to expand\n  if (shouldExpand) {\n    children = childrenWithMatches.map(child => {\n      return expandFilteredNodes(child, filter, matcher)\n    })\n  }\n  return Object.assign({}, node, {\n    children: children,\n    toggled: shouldExpand\n  })\n}\n"]},"metadata":{},"sourceType":"module"}