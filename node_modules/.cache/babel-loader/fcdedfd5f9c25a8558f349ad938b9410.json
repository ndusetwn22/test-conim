{"ast":null,"code":"(function () {\n  if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\n    return;\n  }\n  /**\n   * @param {string} selector\n   * @param {ParentNode} [container]\n   * @returns {HTMLElement[]}\n   */\n\n\n  function $$(selector, container) {\n    return Array.prototype.slice.call((container || document).querySelectorAll(selector));\n  }\n  /**\n   * Returns whether the given element has the given class.\n   *\n   * @param {Element} element\n   * @param {string} className\n   * @returns {boolean}\n   */\n\n\n  function hasClass(element, className) {\n    className = \" \" + className + \" \";\n    return (\" \" + element.className + \" \").replace(/[\\n\\t]/g, \" \").indexOf(className) > -1;\n  }\n  /**\n   * Calls the given function.\n   *\n   * @param {() => any} func\n   * @returns {void}\n   */\n\n\n  function callFunction(func) {\n    func();\n  } // Some browsers round the line-height, others don't.\n  // We need to test for it to position the elements properly.\n\n\n  var isLineHeightRounded = function () {\n    var res;\n    return function () {\n      if (typeof res === 'undefined') {\n        var d = document.createElement('div');\n        d.style.fontSize = '13px';\n        d.style.lineHeight = '1.5';\n        d.style.padding = '0';\n        d.style.border = '0';\n        d.innerHTML = '&nbsp;<br />&nbsp;';\n        document.body.appendChild(d); // Browsers that round the line-height should have offsetHeight === 38\n        // The others should have 39.\n\n        res = d.offsetHeight === 38;\n        document.body.removeChild(d);\n      }\n\n      return res;\n    };\n  }();\n  /**\n   * Highlights the lines of the given pre.\n   *\n   * This function is split into a DOM measuring and mutate phase to improve performance.\n   * The returned function mutates the DOM when called.\n   *\n   * @param {HTMLElement} pre\n   * @param {string} [lines]\n   * @param {string} [classes='']\n   * @returns {() => void}\n   */\n\n\n  function highlightLines(pre, lines, classes) {\n    lines = typeof lines === 'string' ? lines : pre.getAttribute('data-line');\n    var ranges = lines.replace(/\\s+/g, '').split(',').filter(Boolean);\n    var offset = +pre.getAttribute('data-line-offset') || 0;\n    var parseMethod = isLineHeightRounded() ? parseInt : parseFloat;\n    var lineHeight = parseMethod(getComputedStyle(pre).lineHeight);\n    var hasLineNumbers = hasClass(pre, 'line-numbers');\n    var parentElement = hasLineNumbers ? pre : pre.querySelector('code') || pre;\n    var mutateActions =\n    /** @type {(() => void)[]} */\n    [];\n    ranges.forEach(function (currentRange) {\n      var range = currentRange.split('-');\n      var start = +range[0];\n      var end = +range[1] || start;\n      /** @type {HTMLElement} */\n\n      var line = pre.querySelector('.line-highlight[data-range=\"' + currentRange + '\"]') || document.createElement('div');\n      mutateActions.push(function () {\n        line.setAttribute('aria-hidden', 'true');\n        line.setAttribute('data-range', currentRange);\n        line.className = (classes || '') + ' line-highlight';\n      }); // if the line-numbers plugin is enabled, then there is no reason for this plugin to display the line numbers\n\n      if (hasLineNumbers && Prism.plugins.lineNumbers) {\n        var startNode = Prism.plugins.lineNumbers.getLine(pre, start);\n        var endNode = Prism.plugins.lineNumbers.getLine(pre, end);\n\n        if (startNode) {\n          var top = startNode.offsetTop + 'px';\n          mutateActions.push(function () {\n            line.style.top = top;\n          });\n        }\n\n        if (endNode) {\n          var height = endNode.offsetTop - startNode.offsetTop + endNode.offsetHeight + 'px';\n          mutateActions.push(function () {\n            line.style.height = height;\n          });\n        }\n      } else {\n        mutateActions.push(function () {\n          line.setAttribute('data-start', start);\n\n          if (end > start) {\n            line.setAttribute('data-end', end);\n          }\n\n          line.style.top = (start - offset - 1) * lineHeight + 'px';\n          line.textContent = new Array(end - start + 2).join(' \\n');\n        });\n      }\n\n      mutateActions.push(function () {\n        // allow this to play nicely with the line-numbers plugin\n        // need to attack to pre as when line-numbers is enabled, the code tag is relatively which screws up the positioning\n        parentElement.appendChild(line);\n      });\n    });\n    var id = pre.id;\n\n    if (hasLineNumbers && id) {\n      // This implements linkable line numbers. Linkable line numbers use Line Highlight to create a link to a\n      // specific line. For this to work, the pre element has to:\n      //  1) have line numbers,\n      //  2) have the `linkable-line-numbers` class or an ascendant that has that class, and\n      //  3) have an id.\n      var linkableLineNumbersClass = 'linkable-line-numbers';\n      var linkableLineNumbers = false;\n      var node = pre;\n\n      while (node) {\n        if (hasClass(node, linkableLineNumbersClass)) {\n          linkableLineNumbers = true;\n          break;\n        }\n\n        node = node.parentElement;\n      }\n\n      if (linkableLineNumbers) {\n        if (!hasClass(pre, linkableLineNumbersClass)) {\n          // add class to pre\n          mutateActions.push(function () {\n            pre.className = (pre.className + ' ' + linkableLineNumbersClass).trim();\n          });\n        }\n\n        var start = parseInt(pre.getAttribute('data-start') || '1'); // iterate all line number spans\n\n        $$('.line-numbers-rows > span', pre).forEach(function (lineSpan, i) {\n          var lineNumber = i + start;\n\n          lineSpan.onclick = function () {\n            var hash = id + '.' + lineNumber; // this will prevent scrolling since the span is obviously in view\n\n            scrollIntoView = false;\n            location.hash = hash;\n            setTimeout(function () {\n              scrollIntoView = true;\n            }, 1);\n          };\n        });\n      }\n    }\n\n    return function () {\n      mutateActions.forEach(callFunction);\n    };\n  }\n\n  var scrollIntoView = true;\n\n  function applyHash() {\n    var hash = location.hash.slice(1); // Remove pre-existing temporary lines\n\n    $$('.temporary.line-highlight').forEach(function (line) {\n      line.parentNode.removeChild(line);\n    });\n    var range = (hash.match(/\\.([\\d,-]+)$/) || [, ''])[1];\n\n    if (!range || document.getElementById(hash)) {\n      return;\n    }\n\n    var id = hash.slice(0, hash.lastIndexOf('.')),\n        pre = document.getElementById(id);\n\n    if (!pre) {\n      return;\n    }\n\n    if (!pre.hasAttribute('data-line')) {\n      pre.setAttribute('data-line', '');\n    }\n\n    var mutateDom = highlightLines(pre, range, 'temporary ');\n    mutateDom();\n\n    if (scrollIntoView) {\n      document.querySelector('.temporary.line-highlight').scrollIntoView();\n    }\n  }\n\n  var fakeTimer = 0; // Hack to limit the number of times applyHash() runs\n\n  Prism.hooks.add('before-sanity-check', function (env) {\n    var pre = env.element.parentNode;\n    var lines = pre && pre.getAttribute('data-line');\n\n    if (!pre || !lines || !/pre/i.test(pre.nodeName)) {\n      return;\n    }\n    /*\n     * Cleanup for other plugins (e.g. autoloader).\n     *\n     * Sometimes <code> blocks are highlighted multiple times. It is necessary\n     * to cleanup any left-over tags, because the whitespace inside of the <div>\n     * tags change the content of the <code> tag.\n     */\n\n\n    var num = 0;\n    $$('.line-highlight', pre).forEach(function (line) {\n      num += line.textContent.length;\n      line.parentNode.removeChild(line);\n    }); // Remove extra whitespace\n\n    if (num && /^( \\n)+$/.test(env.code.slice(-num))) {\n      env.code = env.code.slice(0, -num);\n    }\n  });\n  Prism.hooks.add('complete', function completeHook(env) {\n    var pre = env.element.parentNode;\n    var lines = pre && pre.getAttribute('data-line');\n\n    if (!pre || !lines || !/pre/i.test(pre.nodeName)) {\n      return;\n    }\n\n    clearTimeout(fakeTimer);\n    var hasLineNumbers = Prism.plugins.lineNumbers;\n    var isLineNumbersLoaded = env.plugins && env.plugins.lineNumbers;\n\n    if (hasClass(pre, 'line-numbers') && hasLineNumbers && !isLineNumbersLoaded) {\n      Prism.hooks.add('line-numbers', completeHook);\n    } else {\n      var mutateDom = highlightLines(pre, lines);\n      mutateDom();\n      fakeTimer = setTimeout(applyHash, 1);\n    }\n  });\n  window.addEventListener('hashchange', applyHash);\n  window.addEventListener('resize', function () {\n    var actions = $$('pre[data-line]').map(function (pre) {\n      return highlightLines(pre);\n    });\n    actions.forEach(callFunction);\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}